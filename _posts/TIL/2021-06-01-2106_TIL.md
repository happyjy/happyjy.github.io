---
title: 2106 TIL
date: 2021-06-01
author: jyoon
category: TIL
tags:
  - TIL
---


# 210620

## Modules, introduction

[Modules, introduction - jsinfo](https://javascript.info/modules-intro)

* 하나의 스크립트는 하나의 모듈 입니다
* 모듈은 서로를 로드하고 특수 지시문 내보니기 및 가져오기를 사용하여 기능을 교환하고 한 모듈의 함수를 다른 모듈에서 호출 할 수 있다.
* export 키워드는 현재 모듈 외부에서 액세스 할 수 있어야 하는 변수 및 함수에 레이블을 지정
* import를 사용하면 다른 모듈에서 기능르가져올 수 있다.

# 210611

## method definitions

[method definitions - mdn](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Method_definitions)

## 함수(Method)란? - mdn

* [함수(Method)란? - mdn](https://developer.mozilla.org/en-US/docs/Glossary/Method)

* function이 object의 property로 사용될때 function을 method라고 한다.
* 두가지 methods가 있다.
  * 1. Instance Method (객체 인스턴스에 의해 수행되는 내장 작업 인 인스턴스 메서드)
  * 2. Static Method (객체 생성자에서 직접 호출되는 작업인 [정적 메서드(static method)](https://developer.mozilla.org/en-US/docs/Glossary/Static_method))

    ```
      // ## static method 예시
      // In the Notifications API, 
      // the Notification.requestPermission() method is called on the actual Notification constructor itself — it is a static method:
      let promise = Notification.requestPermission();

      // ## instance method 예시
      // The Notification.close() method on the other hand, is an instance method — it is called on an specific notification object instance to close the system notification it represents:
      let myNotification = new Notification('This is my notification');

      myNotification.close();
    ```

## Arrow function expressions

* [mdn]](<https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions#arrow_functions_used_as_methods>)으로 알아보는 arrow function, traditional funciton의 차이
* 정의와 아래 세가지 예시 코드로 traditional, Arrow function을 알아 보자
* 세가지 예시 코드
  * traditional, Arrow functions used as methods
  * traditional, Arrow functions used call, apply and bind
  * Perhaps the greatest benefit of using Arrow functions is with DOM-level methods (setTimeout, setInterval, addEventListener) that usually required some kind of closure, call, apply or bind to ensure the function executed in the proper scope.

* Differences & Limitations

  * Does not have its own bindings to this or super, and should not be used as methods.
  * Does not have arguments, or new.target keywords.
  * Not suitable for call, apply and bind methods, which generally rely on establishing a scope.
  * Can not be used as constructors.
  * Can not use yield, within its body.

* traditional, Arrow functions  used as methods

  * 예시 - traditional function in methods

      ```js
        'use strict';

        var obj = { // does not create a new scope
          i: 10,
          // [point]
          b: () => console.log(this.i, this),
          // [point]
          c: function() {
            console.log(this.i, this);
          }
        }

        
        obj.b(); // [point] prints undefined, Window {...} (or the global object)
        obj.c(); // [point] prints 10, Object {...}
      ```

  * 예시 - Arrow function in methods
    * Arrow functions do not have their own this.
    * Another example involving Object.defineProperty():

        ```js
          'use strict';

          var obj = {
            a: 10
          };

          Object.defineProperty(obj, 'b', {
            get: () => {
              // [point]
              console.log(this.a, typeof this.a, this); // undefined 'undefined' Window {...} (or the global object)
              return this.a + 10; // represents global object 'Window', therefore 'this.a' returns 'undefined'
            }
          });
        ```

* traditional, Arrow functions call, apply and bind

  * 결론: arrow function에 call, apply, bind 첫번째 인자에 this scope을 binding 해줘도 arrow function의 this는 window 입니다.
  * 이유: Arrow functions establish "this" based on the scope the Arrow function is defined within.

  * 예시: traditional function vs arrow function

    ```js
        // ----------------------
        // Traditional Example
        // ----------------------
        // A simplistic object with its very own "this".
        var obj = {
            num: 100
        }

        // Setting "num" on window to show how it is NOT used.
        window.num = 2020; // yikes!

        // A simple traditional function to operate on "this"
        var add = function (a, b, c) {
          return this.num + a + b + c;
        }

        // call
        var result = add.call(obj, 1, 2, 3) // establishing the scope as "obj"
        console.log(result) // result 106

        // apply
        const arr = [1, 2, 3]
        var result = add.apply(obj, arr) // establishing the scope as "obj"
        console.log(result) // result 106

        // bind
        var result = add.bind(obj) // establishing the scope as "obj"
        console.log(result(1, 2, 3)) // result 106

        // ----------------------
        // Arrow Example
        // ----------------------

        // A simplistic object with its very own "this".
        var obj = {
            num: 100
        }

        // Setting "num" on window to show how it gets picked up.
        window.num = 2020; // yikes!

        // Arrow Function
        var add = (a, b, c) => this.num + a + b + c;

        // call
        console.log(add.call(obj, 1, 2, 3)) // result 2026

        // apply
        const arr = [1, 2, 3]
        console.log(add.apply(obj, arr)) // result 2026

        // bind
        const bound = add.bind(obj)
        console.log(bound(1, 2, 3)) // result 2026 
    ```
  
* [중요] Perhaps the greatest benefit of using Arrow functions is with DOM-level methods (setTimeout, setInterval, addEventListener) that usually required some kind of closure, call, apply or bind to ensure the function executed in the proper scope

  * 예시: Traditional Example vs Arrow Example

  ```js
      // * Traditional Example:
      var obj = {
          count : 10,
          doSomethingLater : function (){
              // [point] setTimout callback function에서 this가 obj를 가르키는 방법 2
              // 1. bind함수로 this binding 해주기 
              // 2. arrow function으로 
              setTimeout(function(){ // the function executes on the window scope
                  this.count++;
                  console.log(this.count);
              }, 300);
          }
      }
      obj.doSomethingLater(); // console prints "NaN", because the property "count" is not in the window scope.
      


      // * Arrow Example:
      var obj = {
          count : 10,
          // [point][!]
          // * 현재 상황에서 arrow function은 method로 사용될때 부적합, 
          // * callback function에서는 this가 obj 객체를 binding하고 있음으로 적합
          doSomethingLater : function(){ // of course, arrow functions are not suited for methods
              setTimeout( () => { // since the arrow function was created within the "obj", it assumes the object's "this"
                  this.count++;
                  console.log(this.count);
              }, 300);
          }
      }
      obj.doSomethingLater();
  ```

# 210610

## 자주 사용하는 linux

* [35 Linux Basic Commands Every User Should Know](https://www.hostinger.com/tutorials/linux-commands#:~:text=cat%20command,file's%20name%20and%20its%20extension.)

* touch .gitignore
* ls
* pwd
* mkdir
* cat 파일명: 파일 내용 보기
* mv file.txt /home/username/Documents.
* rmdir
* diff

## glob 패턴

* .gitignore, tsconfig.json에 exclude, include에서 사용하는 패턴
* [gitignore glob syntax](https://labs.consol.de/development/git/2017/02/22/gitignore.html)
* 예시
  * .exe로 끝나는 모든 파일 무시: *.exe
  * 그 중, Go.exe는 무시하지 않음: !Go.exe
  * 프로젝트 전체에서 test폴더를 모두 찾아 무시:  test/
  * 프로젝트 최상위에 존재하는 test폴더만 무시:  /test
  * ignore everything: /*
  * but the following: !/.profile

# 210601

## event를 container에 걸어야 하는 이유1

* dom이 새로 추가되는경우에 event를 설정하지 않으면 당연히 등록 안되어 event가 발생하지 않는다.
