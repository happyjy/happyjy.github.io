{"componentChunkName":"component---src-templates-category-posts-js","path":"/category/designpattern","result":{"data":{"allMarkdownRemark":{"totalCount":23,"edges":[{"node":{"id":"ff4d1b1a-f6e6-588b-bdb0-d0dfd785407f","frontmatter":{"title":"BehavioralPattern_01.ChainOfResponsibility","date":"October 11th 2020","author":"jyoon","tags":["ChainOfResponsibility","DesignPattern","BehavioralPattern","JavaScript"],"category":"DesignPattern","image":null},"fields":{"slug":"behavioralpattern-01chainofresponsibility"},"excerpt":"def 객체 결합을 줄인다.  chain of responsibility는 이벤트 버블링과 같다.(선택한 이벤트가 연속적으로 중첩된 컨트롤들로 증식해 나가기 때문이다.) Javascript에서 자주 사용되는 Chaining pattern…"}},{"node":{"id":"d810f0ae-a52f-5cf6-8913-68fa3871d5d6","frontmatter":{"title":"BehavioralPattern_02.Command","date":"October 11th 2020","author":"jyoon","tags":["Command","DesignPattern","BehavioralPattern","JavaScript"],"category":"DesignPattern","image":null},"fields":{"slug":"behavioralpattern-02command"},"excerpt":"def…"}},{"node":{"id":"770bed3c-bb1a-524c-a4d7-9ada3e7dd7c9","frontmatter":{"title":"BehavioralPattern_03.Interpreter","date":"October 11th 2020","author":"jyoon","tags":["Interpreter","DesignPattern","BehavioralPattern","JavaScript"],"category":"DesignPattern","image":null},"fields":{"slug":"behavioralpattern-03interpreter"},"excerpt":"def POINT2 인터프리터 패턴은 최종사용자가 그들의 솔루션을 customize…"}},{"node":{"id":"e6f95539-b1c5-53bd-a35b-046a8197e9b3","frontmatter":{"title":"BehavioralPattern_07.Observer","date":"October 11th 2020","author":"jyoon","tags":["Observer","DesignPattern","BehavioralPattern","JavaScript"],"category":"DesignPattern","image":null},"fields":{"slug":"behavioralpattern-07observer"},"excerpt":"def Observer 패턴은 객체가 이벤트를 구독하고 이벤트 발생시 알림을받는 구독 모델을 제공한다. 이 패턴은 JavaScript를 포함한 이벤트 기반 프로그래밍의 초석이다. Observer…"}},{"node":{"id":"20f90095-28e1-5866-bd10-c6187d5e8b0a","frontmatter":{"title":"BehavioralPattern_06.Memento","date":"October 11th 2020","author":"jyoon","tags":["Memento","DesignPattern","BehavioralPattern","JavaScript"],"category":"DesignPattern","image":null},"fields":{"slug":"behavioralpattern-06memento"},"excerpt":"def Memento 패턴은 객체의 복원뿐만 아니라 임시 저장소를 제공한다. 이런 메커니즘은 state 객체를 저장하는 것을 필요로 하게 지속 기간에 따라 다르며 다를 수 있다.   객체가 유지되고 복원되는 Memento…"}},{"node":{"id":"41b476fa-1109-5b9b-8081-25296540f68d","frontmatter":{"title":"BehavioralPattern_05.Mediator","date":"October 11th 2020","author":"jyoon","tags":["Mediator","DesignPattern","BehavioralPattern","JavaScript"],"category":"DesignPattern","image":null},"fields":{"slug":"behavioralpattern-05mediator"},"excerpt":"def Mediator…"}},{"node":{"id":"ccf5239f-e232-53d7-afd5-311feb71ce46","frontmatter":{"title":"BehavioralPattern_04.Iterator","date":"October 11th 2020","author":"jyoon","tags":["Iterator","DesignPattern","BehavioralPattern","JavaScript"],"category":"DesignPattern","image":null},"fields":{"slug":"behavioralpattern-04iterator"},"excerpt":"def 사용자가 효고적으로 반복분(collection 객체) 사용할 수 있도록 돕는다.   흔한 프로그래밍 task로 collection 객체를 순회하는 것이다. 이런 collection 들은 아마 배열 또는 좀더 복잡한 tree, graph…"}},{"node":{"id":"54b9c124-62aa-52df-a7c7-cf15fa6522f9","frontmatter":{"title":"BehavioralPattern_10.Template Method","date":"October 11th 2020","author":"jyoon","tags":["Template Method","DesignPattern","BehavioralPattern","JavaScript"],"category":"DesignPattern","image":null},"fields":{"slug":"behavioralpattern-10template-method"},"excerpt":"def…"}},{"node":{"id":"406683d1-f85b-54f4-b57d-72065358361a","frontmatter":{"title":"BehavioralPattern_11.Visitor","date":"October 11th 2020","author":"jyoon","tags":["Visitor","DesignPattern","BehavioralPattern","JavaScript"],"category":"DesignPattern","image":null},"fields":{"slug":"behavioralpattern-11visitor"},"excerpt":"def…"}},{"node":{"id":"38ef1c8b-230f-5b10-b91d-6c5f3da83ad8","frontmatter":{"title":"BehavioralPattern_08.State","date":"October 11th 2020","author":"jyoon","tags":["State","DesignPattern","BehavioralPattern","JavaScript"],"category":"DesignPattern","image":null},"fields":{"slug":"behavioralpattern-08state"},"excerpt":"def State 패턴은 각 객체가 특정 상태를 나타내는 제한된 객체 집합에 상태 별 로직을 제공한다.   예1 고객이 온라인으로 TV를 주문한다고 가정했을 때   이 주문이 처리되는 동안 new…"}},{"node":{"id":"4733c012-e36d-585e-a402-aaa051b3937f","frontmatter":{"title":"BehavioralPattern_09.Strategy","date":"October 11th 2020","author":"jyoon","tags":["Strategy","DesignPattern","BehavioralPattern","JavaScript"],"category":"DesignPattern","image":null},"fields":{"slug":"behavioralpattern-09strategy"},"excerpt":"def…"}},{"node":{"id":"6868f4c7-b6be-590c-a52b-ee8c302a5229","frontmatter":{"title":"StructuralPattern_04.Decorator","date":"October 11th 2020","author":"jyoon","tags":["Decorator","DesignPattern","StructuralPattern","JavaScript"],"category":"DesignPattern","image":null},"fields":{"slug":"structuralpattern-04decorator"},"excerpt":"def Decorator pattern은 객체의 행동을 드라마틱하게 확장시키는 것이다. runtime에 새로운 행동을 추가하는 능력은 Decorator객체가 기존 객체를 감싸면서 해낼 수 있다. 여러개의 decorator…"}},{"node":{"id":"be493c6f-05a2-5114-bd42-3822e5034450","frontmatter":{"title":"StructuralPattern_01.Adapter","date":"October 11th 2020","author":"jyoon","tags":["Adapter","DesignPattern","StructuralPattern","JavaScript"],"category":"DesignPattern","image":null},"fields":{"slug":"structuralpattern-01adapter"},"excerpt":"def   POINTinterface…"}},{"node":{"id":"b28a557c-412b-5b51-acd3-a6d4e74741bc","frontmatter":{"title":"StructuralPattern_03.Composite","date":"October 11th 2020","author":"jyoon","tags":["Composite","DesignPattern","StructuralPattern","JavaScript"],"category":"DesignPattern","image":null},"fields":{"slug":"structuralpattern-03composite"},"excerpt":"def collection의 각 item들은 다른 collection을 nested 구조로 가질 수 있다.    트리 구조 는 Composite pattern의 완벽한 예다. 트리의 각 노드는 leaf node subtree of node…"}},{"node":{"id":"38f6c92e-c7e9-54ca-be80-6acdc6a4d888","frontmatter":{"title":"StructuralPattern_02.Bridge","date":"October 11th 2020","author":"jyoon","tags":["Bridge","DesignPattern","StructuralPattern","JavaScript"],"category":"DesignPattern","image":null},"fields":{"slug":"structuralpattern-02bridge"},"excerpt":"def 두 컴포넌트들을 사용한다 두 컴포넌트가 각각 자신의 인터페이스를 가지고 있고 서로를 위해서 역할을 한다. a client, a service Bridege는 high-level 아키택쳐 패턴이다. POINT…"}},{"node":{"id":"44531d98-c6a6-565f-a7b0-c96f672684e7","frontmatter":{"title":"StructuralPattern_06.Flywight","date":"October 11th 2020","author":"jyoon","tags":["Flywight","DesignPattern","StructuralPattern","JavaScript"],"category":"DesignPattern","image":null},"fields":{"slug":"structuralpattern-06flywight"},"excerpt":"def Flyweight 패턴은 많은 수의 세분화 된 객체를 효율적으로 공유하여 메모리를 절약한다. 공유된 flyweight객체는 변경할 수 없다. 즉, 다른 객체와 공유되는 특성을 나타내므로 변경할 수 없다. 본질적으로 Flyweight…"}},{"node":{"id":"dccb6b34-bf11-5ba1-baa1-8d86855bcc0d","frontmatter":{"title":"StructuralPattern_07.Proxy","date":"October 11th 2020","author":"jyoon","tags":["Proxy","DesignPattern","StructuralPattern","JavaScript"],"category":"DesignPattern","image":null},"fields":{"slug":"structuralpattern-07proxy"},"excerpt":"def…"}},{"node":{"id":"587706cf-622f-510b-87cf-26b618dcd4e9","frontmatter":{"title":"StructuralPattern_05.Facade","date":"October 11th 2020","author":"jyoon","tags":["Facade","DesignPattern","StructuralPattern","JavaScript"],"category":"DesignPattern","image":null},"fields":{"slug":"structuralpattern-05facade"},"excerpt":"def   POINT…"}},{"node":{"id":"9201471f-693f-5d28-9959-3d65a725a15d","frontmatter":{"title":"CreationalPattern_01.AbstractFactory","date":"October 8th 2020","author":"jyoon","tags":["AbstractFactory","DesignPattern","CreationalPattern","JavaScript"],"category":"DesignPattern","image":null},"fields":{"slug":"creationalpattern-01abstractfactory"},"excerpt":"def   공통된 속성과 관련된 객체를 만드는 패턴이다.   객제지향 프로그래밍에서 팩토리는 다른 객체를 생성하는 객체이다.   Abstract Factory는 새로 생성 된 객체가 공유하는 주제를 추상화했다.     button, textbox…"}},{"node":{"id":"99905c22-3614-5826-b808-7c1d1f4e421e","frontmatter":{"title":"CreationalPattern_02.Builder","date":"October 8th 2020","author":"jyoon","tags":["Builder","DesignPattern","CreationalPattern","JavaScript"],"category":"DesignPattern","image":null},"fields":{"slug":"creationalpattern-02builder"},"excerpt":"def Builder 패턴을 사용하면 클라이언트가 유형과 콘텐츠만 지정하여 복잡한 객체를 구성 할 수 있다. Construction 세부 사항은 클라이언트에게 완전히 숨겨진다.   Builder…"}},{"node":{"id":"fd8bbe93-d0f1-5f4b-88b7-b21bcd0337d1","frontmatter":{"title":"CreationalPattern_03.Factory Method","date":"October 8th 2020","author":"jyoon","tags":["FactoryMethod","DesignPattern","CreationalPattern","JavaScript"],"category":"DesignPattern","image":null},"fields":{"slug":"creationalpattern-03factory-method"},"excerpt":"def Factory pattern은 사용자가(클라이언트) 원하는대로 새로운 객체를 생성한다. 객체를 생성하는 방법은 new…"}},{"node":{"id":"9e711676-e08f-5ed1-9d59-19cb45511c6c","frontmatter":{"title":"CreationalPattern_04.Prototype","date":"October 8th 2020","author":"jyoon","tags":["Prototype","DesignPattern","CreationalPattern","JavaScript"],"category":"DesignPattern","image":null},"fields":{"slug":"creationalpattern-04prototype"},"excerpt":"def Prototype Pattern은 새로운 객체를 만든다. 객체를 초기화 하지 않은 상태에서 객체를 반환한다. 이것은 초기화되지 않은 객체이며 된다. Prototype pattern은 또한 Property를 패턴을 참조한다.   Prorotype…"}},{"node":{"id":"f6d18e84-3811-5f32-b3bf-febe302b1392","frontmatter":{"title":"CreationalPattern_05.Singlton","date":"October 8th 2020","author":"jyoon","tags":["Singlton","DesignPattern","CreationalPattern","JavaScript"],"category":"DesignPattern","image":null},"fields":{"slug":"creationalpattern-05singlton"},"excerpt":"def 싱글톤패턴은 특정 객체의 인스턴스 수를 하나로 제한한다. 이 단일 인스턴스를 singleton pattern이라고한다.   singleton pattern…"}}]}},"pageContext":{"category":"DesignPattern"}},"staticQueryHashes":["3542266321","3649515864"]}